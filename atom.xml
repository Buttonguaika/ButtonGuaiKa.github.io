<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NullStack</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://buttonguaika.github.io/"/>
  <updated>2018-06-14T04:52:09.409Z</updated>
  <id>https://buttonguaika.github.io/</id>
  
  <author>
    <name>John</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HaxeFlixel官方教程3:基础工作</title>
    <link href="https://buttonguaika.github.io/2018/06/14/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B3-%E5%9F%BA%E7%A1%80%E5%B7%A5%E4%BD%9C/"/>
    <id>https://buttonguaika.github.io/2018/06/14/HaxeFlixel官方教程3-基础工作/</id>
    <published>2018-06-13T17:11:48.000Z</published>
    <updated>2018-06-14T04:52:09.409Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/groundwork/" target="_blank" rel="noopener">原文</a></p><p>现在，是时候思考一下我们要做什么样的游戏，以及我们要如何去实现。</p><p>我们将要做一个十分简单的 “上帝视角”的“地牢行者（dungeon crawler）”小游戏，玩家将控制一个角色在地图内自由行走，与敌人战斗并收集金币。</p><p>所以，我们要如何将这些设计转换到 HaxeFlixel 中实现？</p><ul><li>首先，我们需要我们需要为我们的游戏建立一个“世界” - 也就是说我们需要一个<code>FlxState</code>对象作为一个容纳游戏内容的容器。</li><li>接着是地牢的设计，我们将使用<code>FlxTilemap</code>对象来表示地牢，地牢的地图我们会使用另一个工具来绘制</li><li>我们将使用一个<code>FlxSprite</code>对象来表示玩家的角色，他是一个被玩家控制的精灵序列（sprite）。</li><li>敌人也是使用<code>FlxSprite</code>对象来表示，而且我们将会用一种特别的方式实现几种不同类型的敌人。</li><li>我们当然还需要一套 HUD/界面接口 用于方便玩家知道自己做了哪些事情产生了哪些结果。我们将通过组合<code>FlxGroup</code>，<code>FlxSprite</code>，<code>FlxText</code>，<code>FlxButton</code>对象与其他一些东西来实现。</li></ul><p>我们将会把以上这些工作一个一个实现。</p><p>首先，让我们先来创建一个简单的菜单，在最后我们会实现一个复杂的<code>MenuState</code>提供按钮以实现更多选项，但是目前我们只需要一个显式“Play”的按钮其功能将实现从菜单切换至<code>PlayState</code>。</p><ol><li><p>删除我们前面为<code>PlayState</code>添加的”Hello World”测试的代码。</p><p>现在在<code>PlayState.hx</code>文件所在的同一个文件夹下创建一个新的文件命名为<code>MenuState.hx</code>（<strong>未填写</strong>）。然后你只需要把<code>PlayState.hx</code>中的代码拷贝进这个文件里（但是把类名改为<code>MenuState</code>）：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MenuState</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxState</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br></pre></td></tr></table></figure><p>在类声明之后，我们要定义一个新的变量，你在想要在这个类的任何位置中使用的变量都应该在这个地方定义，我们现在要定义一个<code>FlxButton</code>类型的变量，作为我们的“Play”按钮，所以在这个位置输入：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _btnPlay:<span class="type">FlxButton</span>;</span><br></pre></td></tr></table></figure><p>注意：如果你使用的是 FlashDevelop ，那么现在IDE会因为你的<code>FlxButton</code>变量的定义而自动在类声明的上方加入一段 import 代码（<code>import flixel.ui.FlxButton;</code>），如果跟我一样是用 VSCode 的话那就自己手动码一下吧。</p></li><li><p>现在，在<code>create()</code>函数里位于<code>super.create()</code>的前一行敲入以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_btnPlay = <span class="keyword">new</span> <span class="type">FlxButton</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="string">"play"</span>,clickPlay);</span><br><span class="line">add(_btnPlay);</span><br></pre></td></tr></table></figure><p>这将会创建一个<code>FlxButton</code>对象并赋值给<code>_btnPlay</code>变量，我们告诉他要在<code>(0,0)</code>坐标位置（在游戏画面的左上角）处创建一个按钮，并在其上显示 “Play” ，当玩家点击它时，调用<code>clickPlay()</code>函数（我们暂时还没有实现<code>clickPlay()</code>函数），然后将这个对象添加到舞台上以显示与交互。暂时不要担心按钮的位置，我们稍后将会调整。</p></li><li><p>接下来我们需要定义<code>clickPlay()</code>函数，在类体内那个地方都行，但不要位于其他函数体内的位置，敲入以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickPlay</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    FlxG.switchState(<span class="keyword">new</span> <span class="type">PlayState</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数里它调用了<code>FlxG.switchState()</code>，它的工作是从当前的状态（目前而言也就是<code>MenuState</code>）切换状态至一个新的<code>PlayState</code>实例。</p></li><li><p>从技术上讲，目前为止我们所要实现的功能已经能正常工作了，你可以运行游戏并且会按我们的预期工作，但是我们还差几件事情没有做。首先，我们的按钮需要放置在一个更合理的位置，我们当然可以在创建按钮对象的时候通过传递 x 和 y 坐标值的方式来定义它的位置，但是这里有一个更简单的方法，回到<code>create()</code>函数里，在我们创建<code>FlxButton</code>对象之后，<code>super.create()</code>之前的位置（我会放在按钮对象被到舞台上之前的位置，但是这行代码放在其之后结果也是一样的）添加一行新的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_btnPlay.screenCenter();</span><br></pre></td></tr></table></figure><p><code>screenCenter()</code>函数的功能是将对象的坐标放在水平或垂直抑或（默认的）这两个方向上的中心位置。调用我们的按钮对象上的这个函数，它将会被放置于游戏画面的中心位置。</p></li><li><p>然后我们需要确保游戏是从<code>MenuState</code>状态启动的。打开<code>Main.hx</code>文件，把对<code>PlayState</code>的引用替换成<code>MenuState</code>。</p></li><li><p>如果你开始启动调试，它会显示一个黑色画面，其中间是我们的 “Play” 按钮，点击它会跳转到另一个黑色画面。如果你的结果如上所述，那么就表示一切正常！GREAT！</p></li></ol><p>之后我们还需要创建一个能够在画面里自由行走的简单的 player 精灵（player sprite)。</p><p>首先，我们需要创建一个新的<code>Player</code>类，你可以把类理解为一个容纳了一系列函数的模板，你可以在项目中使用它们，而且还能够通过继承（extend）变为一个新的版本，你可以把继承理解成描摹纸（小时候描画的那种几乎透明的很薄的纸），当你要对一个类进行继承的时候，就类似于你铺了一张新的描摹纸在它上面 - 你依然可以看到上一张纸的内容并且能够描下来，而且你还能在其上添加更多新的东西。</p><p>我们将要通过继承<code>FlxSprite</code>类来创建我们自己的<code>Player</code>类。</p><ol><li><p>在资源管理器里，右键点选 source 文件夹然后点击创建文件：</p><p><img src="/2018/06/14/HaxeFlixel官方教程3-基础工作/img1.jpg" alt=""></p><p>新文件命名为<code>Player.hx</code>然后双击打开。</p></li><li><p>由于 VSCode 环境下目前我还不知道有什么方法可以通过UI界面选择一个文件的父类再自动生成文件，所以下面需要手动敲码。</p></li><li><p>正确添加之后界面大概会像这样：</p><p><img src="/2018/06/14/HaxeFlixel官方教程3-基础工作/img2.jpg" alt=""></p></li><li><p>然后在<code>Player.hx</code>文件里敲入以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> flixel.FlxSprite;</span><br><span class="line"><span class="keyword">import</span> flixel.system.FlxAssets.FlxGraphicAsset;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">FlxSprite</span></span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?X:<span class="type">Float</span>=<span class="number">0</span>, ?Y:<span class="type">Float</span>=<span class="number">0</span>, ?SimpleGraphic:<span class="type">FlxGraphicAsset</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(X,Y,SimpleGraphic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个标准的<code>FlxSprite</code>子类的结构，我们为了使用需要稍微修改一下。</p></li><li><p>首先，去掉构造函数的<code>SimpleGraphic</code>参数，我们的<code>Player</code>精灵用不着这个参数。</p><p>所以：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?X:<span class="type">Float</span>=<span class="number">0</span>, ?Y:<span class="type">Float</span>=<span class="number">0</span>, ?SimpleGraphic:<span class="type">FlxGraphicAsset</span>)</span><br></pre></td></tr></table></figure><p>改写成：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span></span>(?X:<span class="type">Float</span>=<span class="number">0</span>, ?Y:<span class="type">Float</span>=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>还有：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(X,Y,SimpleGraphic);</span><br></pre></td></tr></table></figure><p>改写成：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(X,Y);</span><br></pre></td></tr></table></figure><p>在类里面，我们使用 “super” 关键字来引用父类。所以在我们的 <code>new()</code>/构造函数 中，通过调用<code>super(X,Y)</code>我们是表示将它关联至父类，此例中也就是<code>FlxSprite</code>类，并调用父类构造函数，把传递给我们的 <code>X</code> 和 <code>y</code> 也传递给父类构造函数。</p><p>这里有点细节：<a href="https://www.kancloud.cn/simon_chang/haxe3manual/184189" target="_blank" rel="noopener">Haxe中的继承</a></p></li><li><p>然后我们为了知道我们的精灵在哪我们为它创建一个 占位符图像（placeholder image），所以在<code>super(X,Y)</code>之后添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeGraphic(<span class="number">16</span>,<span class="number">16</span>,FlxColor.BLUE);</span><br></pre></td></tr></table></figure><p>（注意添加<code>import</code>代码导入<code>FlxColor</code>类：<code>import flixel.util.FlxColor;</code>）</p><p>我们这里所做的事情是把这个对象创建为一个 16x16 大小的蓝色放块。</p></li><li><p>现在我们要创建<code>Player</code>对象的实例确保这个对象能够正常工作，并把它添加到<code>PlayState</code>状态里。它暂时还不能移动或做其他任何事情，这个我们稍后会实现它，现在先保存<code>Player.hx</code>文件（<code>Ctrl+S</code>），然后回到<code>PlayState</code>文件里，我们要定义一个<code>Player</code>类的变量，在类体第一行位置添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _player:<span class="type">Player</span>;</span><br></pre></td></tr></table></figure><p>然后在<code>creat()</code>函数里<code>super.create()；</code>之前：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_player = <span class="keyword">new</span> <span class="type">Player</span>(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">add(_player);</span><br></pre></td></tr></table></figure><p>这里所做的事情很简单，为我们的<code>_player</code>变量赋值了一个<code>Player</code>类的实例，告诉他放在<code>(20,20)</code>坐标位置处，并把它添加进<code>PlayState</code>状态里。</p></li><li><p>如果你现在开始调试（可以通过<code>F5</code>打开调试），点击“Play”按钮你应该能看到以下运行结果：</p><p><img src="/2018/06/14/HaxeFlixel官方教程3-基础工作/img3.jpg" alt=""></p><p>接下来我们来实现移动功能！</p></li></ol><p>我们要如何实现player在画面中自由走动的功能？我们要同时支持方向键与 WASD 键实现8个方向上的移动：上，下，左，右以及对角方向。玩家会以一个相对固定的速度移动，但是在停下来的时候会有一个轻微的减速效果来丰富交互体验。</p><p>首先，我们先为 player 定义一个移动速度以及一个减速度量：</p><ol><li><p>在<code>Player</code>类里面，构造函数的上一行添加：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> speed:<span class="type">Float </span>= <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>接着在构造函数里，位于<code>makeGraphic()</code>的调用之前的位置，我们需要加入一点<code>drag</code>（这是一个<code>FlxSprite</code>对象的属性，我不知道怎样翻译比较准确，大概就是可以产生一个拖曳效果）：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drag.x = drag.y = <span class="number">1600</span>;</span><br></pre></td></tr></table></figure><p>在 HaxeFlixel 中<code>drag</code>是实现当对象停止移动时产生减速运动的方式之一。它可以帮助我们当玩家停止按压任何移动按键时，阻止 player 精灵一直朝某个方向移动，我们稍后会调整<code>drag</code>的数值。</p></li><li><p>尽管处理 player 运动的方式有多种多样，但我们可以简单的把处理运动的功能放在 player 类里边；我们要添加几个函数用于跟踪玩家的输入并给予反馈，敲入代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">movement</span></span>():<span class="type">Void</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>在这个函数里，我们将定义一组辅助变量用于在之后的代码里表示当前哪个按键被玩家按压：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _up:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> _down:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> _left:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> _right:<span class="type">Bool </span>= <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>接下来我们要知道玩家希望朝哪个方向移动，我们通过检查当前处于按压状态的按键来获知：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_up = FlxG.keys.anyPressed([UP,W]);</span><br><span class="line">_down = FlxG.keys.anyPressed([DOWN,S]);</span><br><span class="line">_left = FlxG.keys.anyPressed([LEFT,A]);</span><br><span class="line">_right = FlxG.keys.anyPressed([RIGHT,D]);</span><br></pre></td></tr></table></figure><p><code>anyPressed()</code>函数可以获取列表中的按键目前是否处于按压状态；通过传递一个键值数组（数组元素就是按键的名字）当数组中任何一个按键被按压时它会返回<code>true</code>。稍后我们还会使用其他几个类似的函数来检查其他的按键状态。</p></li><li><p>接下来我们需要处理方向冲突的情况，比如当玩家同时按下上和下时，player 会原地不动：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_up &amp;&amp; _down)</span><br><span class="line">&#123;</span><br><span class="line">    _up = _down = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(_left &amp;&amp; _right)</span><br><span class="line">&#123;</span><br><span class="line">    _left = _right = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>未完先po…</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/groundwork/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在，是时候思考一下我们要做什么样的游戏，以及我们要如何去实现。&lt;/
      
    
    </summary>
    
    
      <category term="HaxeFlixel" scheme="https://buttonguaika.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程2:创建项目</title>
    <link href="https://buttonguaika.github.io/2018/06/12/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B2-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>https://buttonguaika.github.io/2018/06/12/HaxeFlixel官方教程2-创建项目/</id>
    <published>2018-06-12T05:22:13.000Z</published>
    <updated>2018-06-12T15:45:41.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于官网教程使用的环境是 HaxeDevelop/FlashDevelop IDE 作为代码的编辑，调试环境，而我是使用 VSCode ，所以环境的搭建我打算另外做一篇教程，并且在必要的时候对系列教程的原文稍作修改以适应我所使用的环境，而官网的教程我就直接从创建项目的部分开始搬运。</p></blockquote><p><a href="http://haxeflixel.com/documentation/creating-a-new-project/" target="_blank" rel="noopener">原文</a></p><h3 id="2-创建一个新的项目"><a href="#2-创建一个新的项目" class="headerlink" title="2-创建一个新的项目"></a>2-创建一个新的项目</h3><p>现在我们要确定我们需要的东西都安装妥当，并为我们的游戏建立所需的框架。所以我们首先创建一个新的项目，使用 VSCode 打开项目并测试它是否正常构建并运行程序。</p><ol><li><p>在命令行窗口（<code>开始-运行-cmd-回车</code>）敲入以下指令：</p><p><code>flixel tpl -n &quot;FlixelTut&quot;</code></p><p>这个指令会在当前目录使用一个空白的模板创建一个新的 Flixel 项目并放置于 FlixelTut 文件夹内（因为我们以 FlixelTut 命名了该项目）</p></li><li><p>如果你跟我一样使用 VSCode 作为开发环境，并且在 <code>haxelib run flixel-tools setup</code> 的时候配置了 VSCode 作为 flixel 创建项目的默认编辑器，并设置为创建新模板或 Demo 时自动启动，那么现在 VSCode 会自动启动并打开该项目。</p></li><li><p>打开 VSCode 的资源管理器。</p></li><li><p>在资源管理器里，你能够看到项目的结构，包含了模板为我们生成的所有文件。</p><p><img src="/2018/06/12/HaxeFlixel官方教程2-创建项目/img1.JPG" alt=""></p></li><li><p>接下来我们要确定我们的项目能够正确的构建与运行。默认情况下，一个崭新的 Flixel 模板项目会从 PlayState 启动游戏。所以从资源管理器双击打开 source 文件夹下的 PlayState 文件。这是一个十分基础的 FlxState 子类的实例。你可以设想一下把 FlxState 看作是一个 “场景（scenes）” 。当你的游戏开始运行时有且只有一个 “状态（state）” 处于活动状态。玩家看得见摸得着的东西都是被“添加（added）”进该状态的，并且通常会把不共享资源的状态相互隔离。</p><p>通常相互隔离的状态负责游戏的不同部分，比如游戏的开始菜单（MenuState）与游戏状态（PlayState），这些状态之间的关系有点像一个个泡泡（这个实在不知道如何翻译）</p><blockquote><p>They are great for having different sections of your game that are sort of in a bubble from one another, such as a <code>MenuState</code> (which we will add later) and the <code>PlayState</code> (where the game is actually played).</p></blockquote><p>稍后你将会看到，但目前为止 PlayState 只有包含了两个函数：<code>create()</code> 与 <code>update()</code>函数。当一个状态被加载进来，他的<code>create()</code>函数会立即被调用。你应该在这里对状态做一些初始化工作。</p><p><code>update()</code> 是所有奇妙的事物发生的地方，他会在游戏运行时按每帧一次的频率调用（默认情况下游戏是 每秒60帧 - 60fps）。当一个 <code>FlxState</code> 对象的 <code>update()</code> 被调用时，它也会调用被添加进该状态的对象的 <code>update()</code> 函数。这基本上就是你的游戏背后的工作原理。稍后我们会更详细的讨论。现在，我们只是想看看我们搭建的东西是不是能够正常运行，所以接下来让我们添加一个简单的 <code>FlxText</code> 对象到这个状态里。</p></li><li><p>在文件的最上方，位于 <code>import flixel.FlxState;</code> 这一行下方添加以下代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flixel.text.FlxText;</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>在 <code>create()</code> 函数里，位于 <code>super.create();</code> 的前一行的位置添加以下代码:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="keyword">new</span> <span class="type">FlxText</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="string">"Hello, World!"</span>));</span><br></pre></td></tr></table></figure><p>然后保存你的修改（<code>Ctrl + s</code>）</p></li><li><p>The Moment of Truth! 点击 VSCode 左侧的小虫子图标打开调试窗口，然后点击绿色小箭头。</p><p><img src="/2018/06/12/HaxeFlixel官方教程2-创建项目/img2.jpg" alt=""></p><p>如果你看到以下结果那么一切都很顺利：</p><p><img src="/2018/06/12/HaxeFlixel官方教程2-创建项目/img3.jpg" alt=""></p><p>行了！你成功构建并运行了你的第一个 HaxeFlixel 项目！</p><blockquote><p>“Big things have small beginnings.”  —— 《Prometheus》</p></blockquote><p>下一节，我们将正式为我们的游戏做一些设计，并开始把每个设想实现整合。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;由于官网教程使用的环境是 HaxeDevelop/FlashDevelop IDE 作为代码的编辑，调试环境，而我是使用 VSCode ，所以环境的搭建我打算另外做一篇教程，并且在必要的时候对系列教程的原文稍作修改以适应我所使用的环境，而官网的教程
      
    
    </summary>
    
    
      <category term="HaxeFlixel" scheme="https://buttonguaika.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HaxeFlixel官方教程:开篇</title>
    <link href="https://buttonguaika.github.io/2018/06/11/HaxeFlixel%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B-%E5%BC%80%E7%AF%87/"/>
    <id>https://buttonguaika.github.io/2018/06/11/HaxeFlixel官方教程-开篇/</id>
    <published>2018-06-11T15:39:01.000Z</published>
    <updated>2018-06-11T15:42:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://haxeflixel.com/documentation/tutorial/" target="_blank" rel="noopener">原文</a></p><p>欢迎来到 HaxeFlixel ！在这系列教程中，你将学习如何使用 HaxeFlixel 从头到尾创建一个完整的游戏，每一步骤都会被打碎成小片段以帮助你度过难关。</p><p>这一系列教程可以面向 Flash，Windows，Aandroid 进行构建。但我们多数时候是编译到 Flash 平台。</p><p>我们将要搭建一个 <strong>dungen crawler</strong> 小游戏。</p><p>首先，让我聊一点关于为何你应该选择 HaxeFlixel :</p><p>HaxeFlixel 的由来要追溯到由 <a href="http://www.adamatomic.com/" target="_blank" rel="noopener">Adam ‘Atomic’ Saltsman</a> 开发的 <a href="http://flixel.org/" target="_blank" rel="noopener">AS3 Flixel 框架</a>。如果你有玩过 <a href="http://www.adamatomic.com/canabalt/" target="_blank" rel="noopener">Canabalt</a>，那么你就见过过了这个框架的早期版本。HaxeFlixel 继承了 Flixel 的一般结构，从 Flash 平台分离出来并整合进强大的开源多平台语言 <a href="http://haxe.org/" target="_blank" rel="noopener">Haxe</a> 中，所以你编写的游戏就可以简单的发布到各个平台上（Windows，Flash，iOS，Android等）。</p><p>当你使用 HaxeFlixel 编写代码时尽管有些变化但与编写 AS3 代码没有太多差别。此外它拥有大量的内置特性 - 类，实用程序，以及函数 - 当你碰上一些常见或复杂的事情时它们可以帮你解决。并且因为 HaxeFlixel 是开源的，当你发现某些事情它做不到，那你可以修改它的源码，同时如果你的修改对其他人是有帮助的，可以把它们<a href="http://haxeflixel.com/documentation/contributing/" target="_blank" rel="noopener">添加进 library</a>。</p><p>它是一个简单易用的代码库（library），而且给予了你足够的自由去实现你能够想到的任何事情，却不会被死板的接口而限制住。</p><p>你可以从这里了解到更多有关于 HaxeFlixel ：<a href="http://haxeflixel.com/documentation/about/" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://haxeflixel.com/documentation/tutorial/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎来到 HaxeFlixel ！在这系列教程中，你将学习如何使用 Ha
      
    
    </summary>
    
    
      <category term="HaxeFlixel" scheme="https://buttonguaika.github.io/tags/HaxeFlixel/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld!</title>
    <link href="https://buttonguaika.github.io/2018/06/10/HelloWorld/"/>
    <id>https://buttonguaika.github.io/2018/06/10/HelloWorld/</id>
    <published>2018-06-10T14:06:04.000Z</published>
    <updated>2018-06-10T14:43:15.166Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>折腾了两天，总算是把博客重新部署回来了，博客的订阅源算是可以用了，欢迎视奸 :) 。</p></blockquote><p>由于最近在研究一个2D游戏框架——<a href="http://haxeflixel.com/" target="_blank" rel="noopener">HaxeFlixel</a>，为了自己回顾每天的学习进程，打算在学习过程里把一些东西整理一下放到博客上来，日后也可以分享给其他感兴趣的人学习。目前在跟HaxeFlixel官网的教程走一遍，由于还没有看到与这个框架有关的中文资料，接下来一段时间我跟到哪就顺便翻译到博客上来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;折腾了两天，总算是把博客重新部署回来了，博客的订阅源算是可以用了，欢迎视奸 :) 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于最近在研究一个2D游戏框架——&lt;a href=&quot;http://haxeflixel.com/&quot; target=&quot;_b
      
    
    </summary>
    
    
  </entry>
  
</feed>
